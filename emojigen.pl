#!/usr/bin/perl

=pod

Use like:

    emojigen.pl tdesktopr/obj-x86_64-linux-gnur/obj/gen/emoji.cpp > emoji.pm

Parses generated sources of Telegram Desktop to Perl code for Telegram Desktop
emoji data - index of picture sprite in emoji_%d.webp, color and postfix flags,
category sections contents.

=cut

use 5.014;
use strict;
use warnings;

use Encode;
use JSON::PP;
use Data::Dumper;

sub uint32 { $_[0] }    # for eval
my @enumSection = qw{
    Recent
    People
    Nature
    Food
    Activity
    Travel
    Objects
    Symbols
};

my $fname = shift;
open FH, "<", $fname
    or die "can't open '$fname': $!";

my $cur;
my ($IdData, $Data, $SectionData);
my %Section;
my ($json, %completions, %name2emoji);

while (<FH>) {
    tr/{}/[]/;
    s/\];\s?$//;
    if (/^$/) {
        $cur = undef;
    }
    if (/const ushort IdData/) {
        $cur = \$IdData;
    }
    elsif (/const DataStruct Data/) {
        $cur = \$Data;
    }
    elsif (/const ushort SectionData/) {
        $cur = \$SectionData;
    }
    elsif (/case Section::(\w+): return (\d+)/) {
        $Section{$1} = $2;
    }
    else {
        $$cur .= $_ if defined $cur;
    }
}
close FH;

$fname = shift;
if ($fname) {
    my $jsontext;
    open FH, "<", $fname
        or die "Can't open JSON input file $fname: $!";
    # slurp all file at once :)
    {
        local $/ = undef;
        $jsontext = <FH>;
        close FH;
    }
    $json = decode_json $jsontext;
}

my @idData      = eval "($IdData)";
my @data        = eval "($Data)";
my @sectionData = eval "($SectionData)";

my @items;
for my $di (@data) {
    my $original    = $di->[0];
    my $idSize      = $di->[1];
    my $postfixed   = $di->[2];
    my $variated    = $di->[3];

    my $bytes = pack "n$idSize", splice(@idData, 0, $idSize);
    my $emoji = decode("UTF-16BE", $bytes);

    push @items, {
        id          => $emoji,
        original    => $original ? $original - 1 : undef,
        postfixed   => $postfixed,
        variated    => $variated,
    };
}

# output
print <<"EOH";
package EmojiTGData;
# AUTOGENERATED by $0

our \$POSTFIX = "\\x{fe0f}";
our \@POSTFIX_REQUIRED = ("\\x{2122}", "\\x{A9}", "\\x{AE}");

our \@enumSection = qw(@enumSection);

EOH

my $idx = 0;
printf "our \@items = (\n";
printf "  { id => %-17s, original => %s, postfixed => %d, variated => %d }, # %d\n",
    Data::Dumper::qquote($_->{id}),
    $_->{original} // "undef",
    $_->{postfixed},
    $_->{variated},
    $idx++
        for @items;
printf ");\n\n";

$idx = 0;
our %emoji2i = ();
printf "our %%emoji2i = (\t# to index / item / id\n";
printf "  %-67s => %d,\n",
    Data::Dumper::qquote($_->{id}),
    $emoji2i{$_->{id}} = $idx++
        for @items;
printf ");\n\n";

my %semibare;
printf "our %%semibare2i = (\t# with POSTFIX as last char chopped\n";
for (grep { length $_->{id} > 1 and not $_->{postfixed} } @items) {
    my $bare = $_->{id};
    $bare =~ s/\x{FE0F}$//;
    next if $bare eq $_->{id};
    $semibare{$bare}++;
    print('#'), warn "duplicate semibare for item #".$emoji2i{$_->{id}}
        if $semibare{$bare} > 1;
    printf "  %-60s => %d,\n",
        Data::Dumper::qquote($bare),
        $emoji2i{$_->{id}};
}
printf ");\n\n";

my %bare;
printf "our %%bare2i = (\t# with *ALL* POSTFIX in string removed\n";
for (grep { length $_->{id} > 1 and not $_->{postfixed} } @items) {
    my $bare = $_->{id};
    $bare =~ s/\x{FE0F}//g;
    next if $bare eq $_->{id} or $semibare{$bare};
    $bare{$bare}++;
    print('#'), warn "duplicate bare for item #" . $emoji2i{$_->{id}}
        if $bare{$bare} > 1;
    printf "  %-40s => %d,\n",
        Data::Dumper::qquote($bare),
        $emoji2i{$_->{id}};
}
printf ");\n\n";

printf "our %%Sections = (\n";
for my $sec (@enumSection) {
    next if $sec =~ /Recent/;
    printf " %9s => [ ", $sec;
    printf "%d, ", $_ for splice @sectionData, 0, $Section{$sec};
    printf "],\n";
}
printf ");\n\n";

if ($json) {
    my $RE = qr/^:[\+\-a-z0-9_]+:$/;
    printf "our %%emoji2names = (\n";
    for my $k (sort {
                hex( ($a =~ /^([0-9a-fA-F]+)-?/)[0] // 0)
            <=>
                hex( ($b =~ /^([0-9a-fA-F]+)-?/)[0] // 0)
        or
            $a cmp $b
    } keys %$json) {
        my $entry = $json->{$k};
        die "invalid 'output' under entry key '$k'"
            unless $entry->{output} =~ /^[0-9a-f-]+$/;
        die "invalid 'alpha_code' under entry key '$k'"
            unless $entry->{alpha_code} =~ /$RE/;

        my $id = join '', map { chr hex } split('-', $entry->{output});
        my @aliases = map { 
            die "invalid 'aliases' under entry key '$k'"
                unless /$RE/;
            $_
        } split('\|', $entry->{aliases});

        # is this supported in Telegram Desktop?
        # if not, still write but commented
        # consider it might be ending with postfix
        my $exact = scalar grep { $_->{id} eq $id } @items;
        my $chopped = 0;
        if (not $exact and $id =~ /\x{fe0f}$/) {
            my $chop = substr $id, 0, -1;
            $chopped = scalar grep { $_->{id} eq $chop } @items;
        }
        if ($exact or $chopped) {
            $completions{$id} = {
                name        => $entry->{name},
                alpha_code  => $entry->{alpha_code},
                aliases     => [ @aliases ],
            };
            $name2emoji{$_} = $id for ($entry->{alpha_code}, @aliases);
        }
        else {
            printf "# ";
        }
        printf " %s => { name => %s, alpha_code => '%s', aliases => [%s] },\n",
            Data::Dumper::qquote($id),
            Data::Dumper::qquote($entry->{name}),
            $entry->{alpha_code},
            join(", ", map { "'$_'" } @aliases);
    }
    printf ");\n\n";

    printf "our %%name2emoji = (\n";
    printf "  '%s' => %s,\n", $_, Data::Dumper::qquote($name2emoji{$_})
        for sort keys %name2emoji;
    printf ");\n\n";
}
    
print "1;\n";
